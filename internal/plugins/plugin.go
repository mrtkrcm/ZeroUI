package plugins

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Plugin defines the interface for application configuration plugins
type Plugin interface {
	// Name returns the name of the plugin
	Name() string
	
	// Description returns a description of the plugin
	Description() string
	
	// DetectConfigPath attempts to find the configuration file path
	DetectConfigPath() (string, error)
	
	// ParseConfig parses the configuration file into a standard format
	ParseConfig(configPath string) (map[string]interface{}, error)
	
	// WriteConfig writes the configuration back to file
	WriteConfig(configPath string, config map[string]interface{}) error
	
	// GetFieldMetadata returns metadata about configurable fields
	GetFieldMetadata() map[string]FieldMeta
	
	// GetPresets returns available presets
	GetPresets() map[string]Preset
	
	// ValidateValue validates a value for a specific field
	ValidateValue(field string, value interface{}) error
	
	// GetHooks returns hooks to run for various events
	GetHooks() map[string]string
}

// FieldMeta contains metadata about a configuration field
type FieldMeta struct {
	Type        string      // choice, string, number, boolean
	Values      []string    // Valid values for choice type
	Default     interface{} // Default value
	Description string      // Field description
	Path        string      // Path in nested config (e.g., "editor.fontSize")
}

// Preset represents a configuration preset
type Preset struct {
	Name        string
	Description string
	Values      map[string]interface{}
}

// Registry manages available plugins
type Registry struct {
	plugins map[string]Plugin
}

// NewRegistry creates a new plugin registry
func NewRegistry() *Registry {
	return &Registry{
		plugins: make(map[string]Plugin),
	}
}

// Register registers a plugin
func (r *Registry) Register(plugin Plugin) error {
	name := plugin.Name()
	if _, exists := r.plugins[name]; exists {
		return fmt.Errorf("plugin %s already registered", name)
	}
	r.plugins[name] = plugin
	return nil
}

// Get retrieves a plugin by name
func (r *Registry) Get(name string) (Plugin, error) {
	plugin, exists := r.plugins[name]
	if !exists {
		return nil, fmt.Errorf("plugin %s not found", name)
	}
	return plugin, nil
}

// List returns a list of all registered plugins
func (r *Registry) List() []string {
	names := make([]string, 0, len(r.plugins))
	for name := range r.plugins {
		names = append(names, name)
	}
	return names
}

// AutoGenerate generates a configuration file for a plugin
func AutoGenerate(plugin Plugin) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	configDir := filepath.Join(home, ".config", "configtoggle", "apps")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	configPath := filepath.Join(configDir, plugin.Name()+".yaml")
	
	// Check if config already exists
	if _, err := os.Stat(configPath); err == nil {
		return fmt.Errorf("configuration for %s already exists", plugin.Name())
	}

	// Detect the actual config path
	actualConfigPath, err := plugin.DetectConfigPath()
	if err != nil {
		return fmt.Errorf("failed to detect config path: %w", err)
	}

	// Build the YAML config
	var config strings.Builder
	config.WriteString(fmt.Sprintf("# Configuration for %s\n", plugin.Name()))
	config.WriteString(fmt.Sprintf("# Auto-generated by configtoggle\n\n"))
	config.WriteString(fmt.Sprintf("name: %s\n", plugin.Name()))
	config.WriteString(fmt.Sprintf("path: %s\n", actualConfigPath))
	config.WriteString(fmt.Sprintf("format: custom\n"))
	config.WriteString(fmt.Sprintf("description: %s\n\n", plugin.Description()))

	// Add fields
	config.WriteString("fields:\n")
	for name, field := range plugin.GetFieldMetadata() {
		config.WriteString(fmt.Sprintf("  %s:\n", name))
		config.WriteString(fmt.Sprintf("    type: %s\n", field.Type))
		if len(field.Values) > 0 {
			config.WriteString("    values:\n")
			for _, value := range field.Values {
				config.WriteString(fmt.Sprintf("      - %s\n", value))
			}
		}
		if field.Default != nil {
			config.WriteString(fmt.Sprintf("    default: %v\n", field.Default))
		}
		if field.Description != "" {
			config.WriteString(fmt.Sprintf("    description: %s\n", field.Description))
		}
		if field.Path != "" {
			config.WriteString(fmt.Sprintf("    path: %s\n", field.Path))
		}
	}

	// Add presets
	presets := plugin.GetPresets()
	if len(presets) > 0 {
		config.WriteString("\npresets:\n")
		for name, preset := range presets {
			config.WriteString(fmt.Sprintf("  %s:\n", name))
			config.WriteString(fmt.Sprintf("    name: %s\n", preset.Name))
			if preset.Description != "" {
				config.WriteString(fmt.Sprintf("    description: %s\n", preset.Description))
			}
			config.WriteString("    values:\n")
			for key, value := range preset.Values {
				config.WriteString(fmt.Sprintf("      %s: %v\n", key, value))
			}
		}
	}

	// Add hooks
	hooks := plugin.GetHooks()
	if len(hooks) > 0 {
		config.WriteString("\nhooks:\n")
		for event, command := range hooks {
			config.WriteString(fmt.Sprintf("  %s: %s\n", event, command))
		}
	}

	// Write the config file
	if err := os.WriteFile(configPath, []byte(config.String()), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}