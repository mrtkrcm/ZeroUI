---
alwaysApply: false
description: Bubble Tea and Lipgloss patterns for TUI development
globs: internal/tui/**/*.go
---

# ZeroUI TUI Patterns & Bubble Tea Conventions

## 🫖 Bubble Tea Fundamentals

### The Elm Architecture in Go
Bubble Tea implements the Elm Architecture:
- **Model**: Application state
- **Update**: State transition function
- **View**: State rendering function
- **Cmd**: Side effects (async operations)

### Basic Component Structure
```go
type Model struct {
    // State fields
    cursor   int
    selected string
    loading  bool
    err      error
}

func (m Model) Init() tea.Cmd {
    return tea.Batch(
        // Initial commands
        tea.EnterAltScreen,
        m.loadData(),
    )
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        switch msg.String() {
        case "q", "ctrl+c":
            return m, tea.Quit
        case "up", "k":
            if m.cursor > 0 {
                m.cursor--
            }
        case "down", "j":
            if m.cursor < len(m.items)-1 {
                m.cursor++
            }
        case "enter":
            return m, m.selectItem(m.cursor)
        }
    case dataLoadedMsg:
        m.items = msg.items
        m.loading = false
        return m, nil
    case errMsg:
        m.err = msg.err
        m.loading = false
        return m, nil
    }

    return m, nil
}

func (m Model) View() string {
    if m.err != nil {
        return m.renderError()
    }

    if m.loading {
        return m.renderLoading()
    }

    return m.renderMain()
}
```

## 🎨 Lipgloss Styling Patterns

### Style Definitions
```go
// Define styles as package variables
var (
    // Color scheme
    primaryColor   = lipgloss.Color("#7D56F4")
    secondaryColor = lipgloss.Color("#44475A")
    successColor   = lipgloss.Color("#50FA7B")
    errorColor     = lipgloss.Color("#FF5555")
    warningColor   = lipgloss.Color("#FFB86C")

    // Base styles
    titleStyle = lipgloss.NewStyle().
        Bold(true).
        Foreground(primaryColor).
        MarginBottom(1)

    subtitleStyle = lipgloss.NewStyle().
        Foreground(secondaryColor).
        Italic(true)

    // Component styles
    buttonStyle = lipgloss.NewStyle().
        Background(primaryColor).
        Foreground(lipgloss.Color("#FFFFFF")).
        Padding(0, 2).
        Bold(true)

    selectedStyle = lipgloss.NewStyle().
        Background(secondaryColor).
        Foreground(lipgloss.Color("#FFFFFF")).
        Bold(true)

    errorStyle = lipgloss.NewStyle().
        Foreground(errorColor).
        Bold(true)

    successStyle = lipgloss.NewStyle().
        Foreground(successColor).
        Bold(true)
)
```

### Layout Patterns
```go
func (m Model) renderMain() string {
    // Header section
    header := m.renderHeader()

    // Main content area
    content := m.renderContent()

    // Footer/status bar
    footer := m.renderFooter()

    // Combine with proper spacing
    return lipgloss.JoinVertical(
        lipgloss.Left,
        header,
        "", // Empty line for spacing
        content,
        "", // Empty line for spacing
        footer,
    )
}

func (m Model) renderContent() string {
    if len(m.items) == 0 {
        return lipgloss.NewStyle().
            Foreground(secondaryColor).
            Italic(true).
            Render("No items found")
    }

    var items []string
    for i, item := range m.items {
        style := lipgloss.NewStyle()
        if i == m.cursor {
            style = selectedStyle
        }

        prefix := "  "
        if i == m.cursor {
            prefix = "▶ "
        }

        items = append(items, style.Render(prefix+item))
    }

    return lipgloss.JoinVertical(lipgloss.Left, items...)
}
```

### Responsive Design
```go
func (m Model) renderResponsive() string {
    width := m.width

    if width < 60 {
        // Mobile layout
        return m.renderCompact()
    } else if width < 100 {
        // Tablet layout
        return m.renderMedium()
    } else {
        // Desktop layout
        return m.renderFull()
    }
}

func (m Model) renderTwoColumn() string {
    leftColumn := m.renderLeftPanel()
    rightColumn := m.renderRightPanel()

    // Create gap between columns
    gap := lipgloss.NewStyle().Width(2).Render("")

    return lipgloss.JoinHorizontal(
        lipgloss.Top,
        leftColumn,
        gap,
        rightColumn,
    )
}
```

## ⌨️ Keybinding Patterns

### Key Message Handling
```go
func (m Model) handleKey(msg tea.KeyMsg) (Model, tea.Cmd) {
    switch msg.String() {
    // Navigation
    case "up", "k":
        return m.moveUp(), nil
    case "down", "j":
        return m.moveDown(), nil
    case "left", "h":
        return m.moveLeft(), nil
    case "right", "l":
        return m.moveRight(), nil

    // Actions
    case "enter", " ":
        return m.selectCurrent(), m.selectedCmd()
    case "esc":
        return m.escape(), nil

    // Shortcuts
    case "g":
        if msg.Type == tea.KeyRunes {
            return m, nil // Wait for second key
        }
    case "gg":
        return m.goToTop(), nil
    case "G":
        return m.goToBottom(), nil

    // Modifiers
    case "ctrl+c", "q":
        return m, tea.Quit
    case "ctrl+r":
        return m, m.refreshCmd()
    }

    return m, nil
}
```

### Key Sequences
```go
type keySequence struct {
    keys   []string
    action func() tea.Cmd
}

func (m Model) handleKeySequence(msg tea.KeyMsg) (Model, tea.Cmd) {
    key := msg.String()

    // Handle multi-key sequences
    switch {
    case m.waitingForSecondKey && key == "g":
        m.waitingForSecondKey = false
        return m.goToTop(), nil
    case key == "g":
        m.waitingForSecondKey = true
        return m, nil
    default:
        m.waitingForSecondKey = false
    }

    return m, nil
}
```

## 🔄 Message Patterns

### Custom Messages
```go
// Define custom message types
type dataLoadedMsg struct {
    items []Item
    timestamp time.Time
}

type errMsg struct {
    err error
    context string
}

type statusMsg struct {
    status string
    progress float64
}

// Message constructors
func dataLoaded(items []Item) tea.Cmd {
    return tea.Cmd(func() tea.Msg {
        return dataLoadedMsg{
            items: items,
            timestamp: time.Now(),
        }
    })
}

func errOccurred(err error, context string) tea.Cmd {
    return tea.Cmd(func() tea.Msg {
        return errMsg{
            err: err,
            context: context,
        }
    })
}
```

### Async Operations
```go
func (m Model) loadData() tea.Cmd {
    return tea.Cmd(func() tea.Msg {
        // Simulate async operation
        go func() {
            items, err := fetchItems()
            if err != nil {
                // Send error message
                // (In real implementation, use a channel or callback)
                return
            }

            // Send success message
            // (In real implementation, use a channel or callback)
        }()

        return nil // Return immediately
    })
}

// Better approach with channels
func (m Model) loadData() tea.Cmd {
    return func() tea.Msg {
        ch := make(chan tea.Msg, 1)

        go func() {
            defer close(ch)

            items, err := m.fetchItems()
            if err != nil {
                ch <- errMsg{err: err, context: "loadData"}
                return
            }

            ch <- dataLoadedMsg{items: items, timestamp: time.Now()}
        }()

        return func() tea.Msg {
            select {
            case msg := <-ch:
                return msg
            default:
                return nil
            }
        }
    }
}
```

## 📊 State Management

### Model Composition
```go
type MainModel struct {
    header  HeaderModel
    content ContentModel
    footer  FooterModel
    focused tea.Model // Currently focused sub-model
}

func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    var cmd tea.Cmd

    // Handle global keys first
    if key, ok := msg.(tea.KeyMsg); ok {
        switch key.String() {
        case "tab":
            return m.cycleFocus(), nil
        case "q":
            return m, tea.Quit
        }
    }

    // Delegate to focused sub-model
    switch m.focused.(type) {
    case HeaderModel:
        m.header, cmd = m.header.Update(msg)
    case ContentModel:
        m.content, cmd = m.content.Update(msg)
    case FooterModel:
        m.footer, cmd = m.footer.Update(msg)
    }

    return m, cmd
}

func (m MainModel) View() string {
    headerView := m.header.View()
    contentView := m.content.View()
    footerView := m.footer.View()

    return lipgloss.JoinVertical(
        lipgloss.Left,
        headerView,
        contentView,
        footerView,
    )
}
```

### State Validation
```go
func (m Model) validateState() error {
    if m.cursor < 0 {
        return errors.New("cursor cannot be negative")
    }

    if m.cursor >= len(m.items) && len(m.items) > 0 {
        return errors.New("cursor out of bounds")
    }

    if m.width <= 0 || m.height <= 0 {
        return errors.New("invalid dimensions")
    }

    return nil
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    // Update state
    newModel := m.handleMessage(msg)

    // Validate state after update
    if err := newModel.validateState(); err != nil {
        newModel.err = err
        return newModel, nil
    }

    return newModel, nil
}
```

## 🎯 Component Lifecycle

### Initialization
```go
func NewModel(options ...Option) Model {
    m := Model{
        // Default values
        cursor: 0,
        loading: true,
        items: make([]Item, 0),
    }

    // Apply options
    for _, option := range options {
        option(&m)
    }

    // Validate initial state
    if err := m.validateState(); err != nil {
        m.err = err
    }

    return m
}

func (m Model) Init() tea.Cmd {
    return tea.Batch(
        // Initial setup commands
        tea.EnterAltScreen,
        tea.HideCursor,
        m.loadInitialData(),
        m.setupKeyboard(),
    )
}
```

### Cleanup
```go
func (m Model) cleanup() tea.Cmd {
    return tea.Batch(
        // Cleanup commands
        tea.ExitAltScreen,
        tea.ShowCursor,
        m.saveState(),
        m.disconnectConnections(),
    )
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        if msg.String() == "q" {
            return m, m.cleanup()
        }
    }

    return m, nil
}
```

## 📚 Key Files
- [internal/tui/components/core/base.go](mdc:internal/tui/components/core/base.go) - Base component implementation
- [internal/tui/styles/styles.go](mdc:internal/tui/styles/styles.go) - Style definitions
- [internal/tui/keys/keys.go](mdc:internal/tui/keys/keys.go) - Keybinding definitions
- [internal/tui/app_state.go](mdc:internal/tui/app_state.go) - Main application state