---
alwaysApply: true
description: File organization and project structure guidelines
---

# ZeroUI File Organization

## ğŸ“ Project Structure

### Root Level Organization
```
zeroui/
â”œâ”€â”€ .cursor/           # Cursor IDE rules and configuration
â”‚   â””â”€â”€ rules/        # Development guidelines and patterns
â”œâ”€â”€ cmd/              # Main applications and CLI commands
â”œâ”€â”€ internal/         # Private application code
â”œâ”€â”€ pkg/              # Public library code (future use)
â”œâ”€â”€ raycast-extension/# Raycast extension
â”œâ”€â”€ scripts/          # Build and deployment scripts
â”œâ”€â”€ testdata/         # Test data and fixtures
â”œâ”€â”€ docs/             # Documentation (future use)
â”œâ”€â”€ .gitignore       # Git ignore patterns
â”œâ”€â”€ go.mod           # Go module definition
â”œâ”€â”€ go.sum           # Go module checksums
â”œâ”€â”€ main.go          # Application entry point
â””â”€â”€ README.md        # Project documentation
```

### Internal Package Structure
```
internal/
â”œâ”€â”€ tui/              # Terminal User Interface
â”‚   â”œâ”€â”€ components/   # Reusable UI components
â”‚   â”œâ”€â”€ styles/       # Styling and theming
â”‚   â”œâ”€â”€ keys/         # Keybinding definitions
â”‚   â””â”€â”€ util/         # Utility functions
â”œâ”€â”€ logging/          # Logging infrastructure
â”œâ”€â”€ toggle/           # Feature toggle system
â””â”€â”€ cache/            # Caching mechanisms (future use)
```

## ğŸ—ï¸ Component Architecture

### Component Organization (`internal/tui/components/`)
```
components/
â”œâ”€â”€ core/             # Core interfaces and base components
â”‚   â”œâ”€â”€ interfaces.go # Component contracts
â”‚   â”œâ”€â”€ base.go      # Base component implementation
â”‚   â”œâ”€â”€ layout.go    # Layout utilities
â”‚   â””â”€â”€ config_types.go # Configuration types
â”œâ”€â”€ display/          # Display and rendering components
â”‚   â”œâ”€â”€ toast.go     # Toast notifications
â”‚   â”œâ”€â”€ help.go      # Help systems
â”‚   â”œâ”€â”€ status_bar.go # Status indicators
â”‚   â””â”€â”€ glamour_help.go # Enhanced help rendering
â”œâ”€â”€ forms/            # Form components
â”‚   â”œâ”€â”€ forms.go     # Form utilities
â”‚   â”œâ”€â”€ enhanced_config.go # Configuration forms
â”‚   â”œâ”€â”€ types.go     # Form types
â”‚   â””â”€â”€ huh_config_form.go # Huh-based forms
â”œâ”€â”€ ui/               # UI integration components
â”‚   â”œâ”€â”€ ui_integration.go # UI manager
â”‚   â”œâ”€â”€ enhanced_app_list.go # Application lists
â”‚   â””â”€â”€ screenshot_component.go # Screenshot functionality
â””â”€â”€ app/              # Application-specific components
    â”œâ”€â”€ app_card.go  # Individual app cards
    â”œâ”€â”€ app_grid.go  # Grid layouts
    â”œâ”€â”€ app_scanner.go # App scanning
    â””â”€â”€ delightful_ui.go # Enhanced UI implementations
```

### Naming Conventions
```go
# Files and directories
snake_case/          # Directory names
snake_case.go        # Go file names
PascalCase.go        # Test file names: ComponentName_test.go

# Types and functions
PascalCase          # Exported types, functions, constants
camelCase           # Internal types, functions, variables

# Component files
component_name.go   # Main component file
component_name_test.go # Test file
```

## ğŸ“‹ File Content Guidelines

### Package Declarations
```go
// Package names match directory names
// internal/tui/components/core/ â†’ package core
package core

// internal/tui/components/app/ â†’ package app
package app

// internal/tui/components/ui/ â†’ package ui
package ui
```

### Import Organization
```go
import (
    // Standard library imports (alphabetical)
    "fmt"
    "os"
    "path/filepath"
    "strings"

    // Third-party imports (alphabetical)
    "github.com/charmbracelet/bubbles"
    "github.com/charmbracelet/bubbletea"
    "github.com/charmbracelet/lipgloss"

    // Local imports (grouped by internal/external)
    "github.com/mrtkrcm/ZeroUI/internal/logging"
    "github.com/mrtkrcm/ZeroUI/internal/tui/styles"
)
```

### File Structure Template
```go
// Package documentation
package componentname

import (
    // imports
)

// Type definitions
type ComponentName struct {
    // fields
}

// Constants
const (
    // constants
)

// Global variables
var (
    // global variables
)

// Init function (if needed)
func init() {
    // initialization code
}

// Constructor functions
func NewComponentName(options ...Option) *ComponentName {
    // constructor implementation
}

// Main type methods
func (c *ComponentName) MethodName() ReturnType {
    // method implementation
}

// Helper functions
func helperFunction() {
    // helper implementation
}
```

## ğŸ¯ Component File Patterns

### Interface Definitions (`interfaces.go`)
```go
// Define component contracts
type Component interface {
    tea.Model
    GetID() string
}

type Focusable interface {
    Component
    Focus() tea.Cmd
    Blur() tea.Cmd
}

type Sizeable interface {
    Component
    SetSize(width, height int) tea.Cmd
    GetSize() (int, int)
}
```

### Base Implementations (`base.go`)
```go
// Provide base implementations
type BaseComponent struct {
    id     string
    width  int
    height int
    focused bool
}

func (b *BaseComponent) GetID() string {
    return b.id
}

func (b *BaseComponent) SetSize(width, height int) tea.Cmd {
    b.width = width
    b.height = height
    return nil
}

func (b *BaseComponent) GetSize() (int, int) {
    return b.width, b.height
}
```

### Main Components
```go
// Specific component implementations
type ApplicationList struct {
    *BaseComponent
    items    []ApplicationItem
    cursor   int
    selected string
}

func NewApplicationList() *ApplicationList {
    return &ApplicationList{
        BaseComponent: &BaseComponent{
            id: "application-list",
        },
        items: make([]ApplicationItem, 0),
    }
}

func (a *ApplicationList) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    // Update logic
    return a, nil
}

func (a *ApplicationList) View() string {
    // Render logic
    return ""
}
```

## ğŸ§ª Test File Organization

### Test Structure
```
component/
â”œâ”€â”€ component.go
â”œâ”€â”€ component_test.go
â””â”€â”€ testdata/
    â”œâ”€â”€ test1.json
    â”œâ”€â”€ test2.json
    â””â”€â”€ golden/
        â”œâ”€â”€ test1.golden
        â””â”€â”€ test2.golden
```

### Test File Patterns
```go
// component_test.go
package component

import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestComponent_New(t *testing.T) {
    // Test constructor
}

func TestComponent_Update(t *testing.T) {
    // Test update logic
}

func TestComponent_View(t *testing.T) {
    // Test rendering
}

func TestComponent_ErrorHandling(t *testing.T) {
    // Test error scenarios
}
```

## ğŸ“š Documentation Files

### README Files
```
# Component README
â”œâ”€â”€ Overview
â”œâ”€â”€ Usage Examples
â”œâ”€â”€ Configuration
â”œâ”€â”€ API Reference
â””â”€â”€ Contributing
```

### Code Documentation
```go
// Package-level documentation
// Package componentname provides [description of functionality].
//
// Usage:
//
//	import "github.com/mrtkrcm/ZeroUI/internal/tui/components/componentname"
//
//	comp := componentname.New()
//	model, cmd := comp.Update(msg)
package componentname

// Function documentation
// NewComponentName creates a new instance of ComponentName with default settings.
// It initializes the component with sensible defaults and prepares it for use.
func NewComponentName() *ComponentName {
    // implementation
}

// Method documentation
// Update handles incoming messages and updates the component state accordingly.
// It implements the Bubble Tea update loop pattern.
func (c *ComponentName) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    // implementation
}
```

## ğŸ”§ Configuration Files

### Style Configuration
```go
// styles/styles.go
package styles

import "github.com/charmbracelet/lipgloss"

var (
    // Color palette
    PrimaryColor   = lipgloss.Color("#7D56F4")
    SecondaryColor = lipgloss.Color("#44475A")
    SuccessColor   = lipgloss.Color("#50FA7B")
    ErrorColor     = lipgloss.Color("#FF5555")

    // Component styles
    ButtonStyle = lipgloss.NewStyle().
        Background(PrimaryColor).
        Foreground(lipgloss.Color("#FFFFFF")).
        Padding(0, 2).
        Bold(true)
)
```

### Keybinding Configuration
```go
// keys/keys.go
package keys

import "github.com/charmbracelet/bubbles/key"

var (
    // Navigation keys
    Up = key.NewBinding(
        key.WithKeys("up", "k"),
        key.WithHelp("â†‘/k", "move up"),
    )

    Down = key.NewBinding(
        key.WithKeys("down", "j"),
        key.WithHelp("â†“/j", "move down"),
    )

    // Action keys
    Select = key.NewBinding(
        key.WithKeys("enter", " "),
        key.WithHelp("enter/space", "select"),
    )

    Quit = key.NewBinding(
        key.WithKeys("q", "ctrl+c"),
        key.WithHelp("q", "quit"),
    )
)
```

## ğŸ“ Raycast Extension Structure

### Extension Organization
```
raycast-extension/
â”œâ”€â”€ src/                    # Source code
â”‚   â”œâ”€â”€ utils.ts           # ZeroUI integration
â”‚   â”œâ”€â”€ list-apps.tsx      # Main app list
â”‚   â”œâ”€â”€ toggle-config.tsx  # Configuration toggle
â”‚   â”œâ”€â”€ menubar.tsx        # Menu bar integration
â”‚   â””â”€â”€ cache-management.tsx # Cache management
â”œâ”€â”€ assets/                # Static assets
â”‚   â”œâ”€â”€ icon.svg          # Extension icon
â”‚   â””â”€â”€ *.svg             # Other icons
â”œâ”€â”€ node_modules/         # Dependencies
â”œâ”€â”€ package.json          # Extension manifest
â”œâ”€â”€ tsconfig.json         # TypeScript config
â””â”€â”€ README.md             # Extension docs
```

### TypeScript Patterns
```typescript
// utils.ts - Integration layer
export class ZeroUI {
  private zerouiPath: string;
  private cache: Map<string, CacheEntry>;

  async executeCommand(command: string, args: string[] = []): Promise<ZeroUIResult> {
    // Command execution with caching
  }
}

// Component files
export default function Component() {
  const [state, setState] = useState(initialState);

  useEffect(() => {
    loadData();
  }, []);

  return (
    <List>
      {/* Component JSX */}
    </List>
  );
}
```

## ğŸ¯ File Organization Best Practices

### 1. Single Responsibility
- Each file should have one primary purpose
- Split large files into logical components
- Keep related functionality together

### 2. Consistent Naming
- Use descriptive, consistent names
- Follow Go naming conventions
- Use consistent file naming patterns

### 3. Logical Grouping
- Group related files in directories
- Keep interface definitions with implementations
- Separate concerns appropriately

### 4. Import Hygiene
- Minimize import cycles
- Use internal packages appropriately
- Keep imports organized and clean

### 5. Documentation
- Document package purposes
- Include usage examples
- Keep documentation up-to-date

## ğŸ“š Key Directories
- [internal/tui/components/](mdc:internal/tui/components/) - Component architecture
- [internal/tui/styles/](mdc:internal/tui/styles/) - Styling definitions
- [raycast-extension/src/](mdc:raycast-extension/src/) - Extension source
- [cmd/](mdc:cmd/) - CLI commands