---
alwaysApply: true
description: Go development patterns and conventions used in ZeroUI
globs: *.go
---

# ZeroUI Go Development Practices

## ğŸ—ï¸ Project Structure

### Standard Go Layout
```
zeroui/
â”œâ”€â”€ cmd/                    # Main applications
â”‚   â”œâ”€â”€ enhanced_ui.go     # Enhanced UI command
â”‚   â””â”€â”€ root.go            # Root command (CLI entry)
â”œâ”€â”€ internal/              # Private application code
â”‚   â”œâ”€â”€ tui/              # Terminal UI package
â”‚   â”œâ”€â”€ logging/          # Logging utilities
â”‚   â””â”€â”€ toggle/           # Feature toggle system
â”œâ”€â”€ pkg/                  # Public library code (if any)
â”œâ”€â”€ testdata/             # Test data files
â”œâ”€â”€ scripts/              # Build/deployment scripts
â””â”€â”€ docs/                 # Documentation
```

### TUI-Specific Structure
```
internal/tui/
â”œâ”€â”€ components/           # Reusable UI components
â”‚   â”œâ”€â”€ core/            # Core interfaces and types
â”‚   â”œâ”€â”€ display/         # Display/rendering components
â”‚   â”œâ”€â”€ forms/           # Form components
â”‚   â”œâ”€â”€ ui/              # UI integration components
â”‚   â””â”€â”€ app/             # App-specific components
â”œâ”€â”€ styles/              # Styling and themes
â”œâ”€â”€ keys/                # Keybinding definitions
â”œâ”€â”€ registry/            # Component registration
â””â”€â”€ util/                # Utility functions
```

## ğŸ“ Code Conventions

### Naming Conventions
```go
// Types and interfaces
type ApplicationList struct{}    // PascalCase for exported types
type component interface{}       // camelCase for internal types

// Methods
func (a *ApplicationList) Render() string  // PascalCase for exported methods
func (a *ApplicationList) init()           // camelCase for internal methods

// Variables
var globalConfig *Config        // PascalCase for exported variables
var internalState state         // camelCase for internal variables

// Constants
const MaxRetries = 3           // PascalCase for exported constants
const defaultTimeout = 30      // camelCase for internal constants
```

### Error Handling
```go
// Always return errors, don't panic in library code
func (c *Component) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case error:
        // Handle error gracefully
        c.err = msg
        return c, nil
    default:
        // Normal processing
    }
    return c, nil
}

// Use structured error types
type ValidationError struct {
    Field   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation error for %s: %s", e.Field, e.Message)
}
```

### Bubble Tea Patterns
```go
// Model definition
type Model struct {
    width   int
    height  int
    focused bool
    err     error
}

// Required Bubble Tea methods
func (m Model) Init() tea.Cmd {
    return tea.Batch(
        // Initialization commands
        tea.EnterAltScreen,
        m.loadData(),
    )
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.WindowSizeMsg:
        m.width = msg.Width
        m.height = msg.Height
        return m, nil

    case tea.KeyMsg:
        switch msg.String() {
        case "q", "esc":
            return m, tea.Quit
        case "tab":
            m.focused = !m.focused
            return m, nil
        }
    }

    return m, nil
}

func (m Model) View() string {
    if m.err != nil {
        return m.renderError()
    }

    return m.renderMain()
}
```

## ğŸ¨ Styling Patterns

### Lipgloss Usage
```go
// Define styles at package level
var (
    titleStyle = lipgloss.NewStyle().
        Bold(true).
        Foreground(lipgloss.Color("#7D56F4")).
        MarginBottom(1)

    errorStyle = lipgloss.NewStyle().
        Foreground(lipgloss.Color("#FF5555")).
        Bold(true)

    successStyle = lipgloss.NewStyle().
        Foreground(lipgloss.Color("#50FA7B"))
)

// Apply styles in View method
func (m Model) renderHeader() string {
    title := titleStyle.Render("ZeroUI Configuration")
    return lipgloss.JoinVertical(
        lipgloss.Left,
        title,
        "",
        m.renderStatus(),
    )
}
```

### Layout Patterns
```go
func (m Model) renderMain() string {
    // Use lipgloss.JoinVertical/Horizontal for layout
    leftPanel := m.renderLeftPanel()
    rightPanel := m.renderRightPanel()

    return lipgloss.JoinHorizontal(
        lipgloss.Top,
        leftPanel,
        lipgloss.NewStyle().Padding(0, 2).Render(""), // Gap
        rightPanel,
    )
}
```

## ğŸ”§ Utility Patterns

### Configuration Management
```go
// Use functional options pattern for configuration
type Config struct {
    timeout time.Duration
    retries int
    debug   bool
}

type Option func(*Config)

func WithTimeout(timeout time.Duration) Option {
    return func(c *Config) {
        c.timeout = timeout
    }
}

func WithRetries(retries int) Option {
    return func(c *Config) {
        c.retries = retries
    }
}

func NewConfig(options ...Option) *Config {
    config := &Config{
        timeout: 30 * time.Second,
        retries: 3,
        debug:   false,
    }

    for _, option := range options {
        option(config)
    }

    return config
}
```

### Logging
```go
// Use structured logging
type Logger interface {
    Debug(msg string, args ...interface{})
    Info(msg string, args ...interface{})
    Warn(msg string, args ...interface{})
    Error(msg string, args ...interface{})
}

// Implementation
func (l *CharmLogger) Info(msg string, args ...interface{}) {
    if l.level <= InfoLevel {
        fmt.Fprintf(l.writer, "[INFO] %s\n", fmt.Sprintf(msg, args...))
    }
}
```

## ğŸ§ª Testing Patterns

### Table-Driven Tests
```go
func TestComponent_Update(t *testing.T) {
    tests := []struct {
        name     string
        msg      tea.Msg
        expected string
    }{
        {
            name:     "quit on q key",
            msg:      tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}},
            expected: "quit",
        },
        {
            name:     "toggle focus on tab",
            msg:      tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'\t'}},
            expected: "focus",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            m := NewModel()
            updatedModel, cmd := m.Update(tt.msg)

            // Assertions
            assert.Equal(t, tt.expected, updatedModel.GetState())
        })
    }
}
```

### Component Testing
```go
func TestApplicationList_Render(t *testing.T) {
    apps := []Application{
        {Name: "ghostty", Status: StatusReady},
        {Name: "alacritty", Status: StatusNotInstalled},
    }

    list := NewApplicationList(apps)

    // Test rendering
    view := list.View()
    assert.Contains(t, view, "ghostty")
    assert.Contains(t, view, "alacritty")

    // Test with specific width
    list.SetSize(80, 24)
    view = list.View()
    // Verify layout fits within bounds
}
```

## ğŸ“š Key Files
- [internal/tui/components/core/interfaces.go](mdc:internal/tui/components/core/interfaces.go) - Core interfaces
- [internal/tui/app_state.go](mdc:internal/tui/app_state.go) - Main application state
- [internal/tui/styles/styles.go](mdc:internal/tui/styles/styles.go) - Styling definitions
- [main.go](mdc:main.go) - Application entry point