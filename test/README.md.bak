# ZeroUI Test Suite

This directory contains the test suite and testing utilities for the ZeroUI project.

## Test Organization

### Directory Structure
```
test/
├── helpers/           # Shared test utilities and helpers
│   ├── testing_env.go # Environment setup for tests
│   └── common.go      # Common test utilities
└── README.md         # This file

test/
├── integration/      # Integration tests
└── performance/      # Performance tests
```

### Test File Naming Convention
- **Unit tests**: `{package}_test.go` (e.g., `container_test.go`)
- **Integration tests**: `{feature}_integration_test.go`
- **Performance tests**: `{component}_performance_test.go`
- **Main test setup**: `TestMain` function in each package

## Test Categories

### Unit Tests
Located in the same package directory as the code they test:
- Test individual functions and methods
- Mock external dependencies
- Focus on isolated functionality

### Integration Tests
Located in `test/integration/`:
- Test interactions between components
- Use real dependencies where possible
- Test end-to-end workflows

### Performance Tests
Located in `test/performance/`:
- Benchmark critical functions
- Test memory usage patterns
- Validate performance optimizations

## Test Environment Setup

### Automatic Environment Setup
Each package should use the standardized `TestMain` approach:

```go
func TestMain(m *testing.M) {
    helpers.RunTestMainWithCleanup(m, "package-name", "temp-dir-prefix-", nil)
}
```

This automatically:
- Prepends `testdata/bin` to PATH
- Creates isolated temporary HOME directory
- Cleans up after tests complete

### Manual Environment Setup
For more control, use the common helpers:

```go
func TestMyFunction(t *testing.T) {
    config := helpers.SetupTestEnvironment(t, "my-package")

    // Test code here
    // config.TempDir contains the temporary HOME directory
}
```

## Test Helpers

### Common Utilities
- `helpers.AssertNoPanic()` - Ensure functions don't panic
- `helpers.AssertDuration()` - Check function execution time
- `helpers.WaitForCondition()` - Wait for async conditions
- `helpers.CreateTempFile()` - Create temporary files
- `helpers.ReadFileSafe()` - Safe file reading

### Test Data
- Test binaries in `testdata/bin/`
- Test configurations in `testdata/configs/`
- Visual snapshots in `testdata/snapshots/`

## Writing Tests

### Test Structure
```go
func TestFeature(t *testing.T) {
    // Setup
    config := helpers.SetupTestEnvironment(t, "package-name")

    // Given
    input := "test input"

    // When
    result := FunctionUnderTest(input)

    // Then
    if result != expected {
        t.Errorf("Expected %v, got %v", expected, result)
    }
}
```

### Best Practices
1. **Use descriptive test names**: `TestUserCanLogin` not `TestLogin`
2. **Test one thing per test**: Each test should have a single assertion
3. **Use table-driven tests**: For testing multiple inputs/outputs
4. **Clean up resources**: Use `t.Cleanup()` for cleanup
5. **Avoid test dependencies**: Tests should be independent
6. **Mock external dependencies**: Don't rely on external services

### Testing Patterns

#### Table-Driven Tests
```go
func TestFunction(t *testing.T) {
    tests := []struct{
        name string
        input string
        expected string
    }{
        {"valid input", "input", "expected"},
        {"empty input", "", "empty"},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Function(tt.input)
            if result != tt.expected {
                t.Errorf("Expected %v, got %v", tt.expected, result)
            }
        })
    }
}
```

#### Async Testing
```go
func TestAsyncOperation(t *testing.T) {
    done := make(chan bool)

    go func() {
        // Simulate async operation
        time.Sleep(100 * time.Millisecond)
        done <- true
    }()

    helpers.WaitForCondition(t, func() bool {
        select {
        case <-done:
            return true
        default:
            return false
        }
    }, 1*time.Second, "Async operation should complete")
}
```

## Running Tests

### All Tests
```bash
go test ./...
```

### Specific Package
```bash
go test ./internal/container
```

### With Coverage
```bash
go test -cover ./internal/container
```

### Integration Tests
```bash
go test ./test/integration
```

### Performance Tests
```bash
go test -bench=. ./internal/performance
```

## Test Data Management

### Test Binaries
- Add stub binaries to `testdata/bin/`
- Make executable: `chmod +x testdata/bin/*`
- Use in tests via PATH setup

### Test Configurations
- Store test configs in `testdata/configs/`
- Use relative paths in tests

### Visual Snapshots
- Generated automatically during tests
- Compare with `testdata/snapshots/` for regression testing

## Continuous Integration

### GitHub Actions
Tests run automatically on:
- Push to main branch
- Pull requests
- Manual trigger

### Local CI
```bash
make test        # Run all tests
make test-setup  # Setup test environment
```

## Troubleshooting

### Common Issues

1. **PATH issues**: Ensure `testdata/bin` is in PATH
2. **HOME directory**: Tests create isolated HOME directories
3. **File permissions**: Test binaries need execute permissions
4. **Race conditions**: Use proper synchronization in async tests

### Debug Tips
- Use `t.Logf()` for debug output
- Set `ZEROUI_TEST_MODE=true` for test-specific behavior
- Check `testdata/bin/` for missing test binaries
- Verify file permissions with `ls -la testdata/bin/`

## Contributing

When adding tests:
1. Follow the naming conventions
2. Add appropriate test helpers if needed
3. Update this documentation if patterns change
4. Ensure tests pass in CI before merging
